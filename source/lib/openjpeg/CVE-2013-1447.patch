diff -Naur openjpeg-1.5.1.old/libopenjpeg/cio.c openjpeg-1.5.1/libopenjpeg/cio.c
--- openjpeg-1.5.1.old/libopenjpeg/cio.c	2012-09-13 09:58:39.000000000 +0200
+++ openjpeg-1.5.1/libopenjpeg/cio.c	2014-10-14 09:40:28.012179400 +0200
@@ -106,6 +106,11 @@
  * pos : position, in number of bytes, from the beginning of the stream
  */
 void OPJ_CALLCONV cio_seek(opj_cio_t *cio, int pos) {
+	if ((cio->start + pos) > cio->end) {
+		opj_event_msg(cio->cinfo, EVT_ERROR, "error: trying to seek past the end of the codestream (start = %d, change = %d, end = %d\n", cio->start, pos, cio->end);
+		cio->bp = cio->end;
+		return;
+	}
 	cio->bp = cio->start + pos;
 }
 
@@ -113,6 +118,7 @@
  * Number of bytes left before the end of the stream.
  */
 int cio_numbytesleft(opj_cio_t *cio) {
+	assert((cio->end - cio->bp) >= 0);
 	return cio->end - cio->bp;
 }
 
@@ -184,6 +190,12 @@
  * n : number of bytes to skip
  */
 void cio_skip(opj_cio_t *cio, int n) {
+ 	assert((cio->bp + n) >= cio->bp);
+	if (((cio->bp + n) < cio->start) || ((cio->bp + n) > cio->end)) {
+		opj_event_msg(cio->cinfo, EVT_ERROR, "error: trying to skip bytes past the end of the codestream (current = %d, change = %d, end = %d\n", cio->bp, n, cio->end);
+		cio->bp = cio->end;
+		return;
+	}
 	cio->bp += n;
 }
 
diff -Naur openjpeg-1.5.1.old/libopenjpeg/j2k.c openjpeg-1.5.1/libopenjpeg/j2k.c
--- openjpeg-1.5.1.old/libopenjpeg/j2k.c	2012-09-13 09:58:39.000000000 +0200
+++ openjpeg-1.5.1/libopenjpeg/j2k.c	2014-10-14 09:38:25.791188800 +0200
@@ -470,7 +470,7 @@
 
 	image->comps = (opj_image_comp_t*) opj_calloc(image->numcomps, sizeof(opj_image_comp_t));
 	for (i = 0; i < image->numcomps; i++) {
-		int tmp, w, h;
+		int tmp/*, w, h*/;
 		tmp = cio_read(cio, 1);		/* Ssiz_i */
 		image->comps[i].prec = (tmp & 0x7f) + 1;
 		image->comps[i].sgnd = tmp >> 7;
@@ -505,10 +505,18 @@
 			
 		}
 #endif /* USE_JPWL */
+		{
+			if (!(image->comps[i].dx * image->comps[i].dy)) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR,
+					"JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\n",
+					i, i, image->comps[i].dx, image->comps[i].dy);
+					return;
+			}
+		}
 
 		/* TODO: unused ? */
-		w = int_ceildiv(image->x1 - image->x0, image->comps[i].dx);
-		h = int_ceildiv(image->y1 - image->y0, image->comps[i].dy);
+/*		w = int_ceildiv(image->x1 - image->x0, image->comps[i].dx);
+		h = int_ceildiv(image->y1 - image->y0, image->comps[i].dy);*/
 
 		image->comps[i].resno_decoded = 0;	/* number of resolution decoded */
 		image->comps[i].factor = cp->reduce; /* reducing factor per component */
@@ -1964,6 +1972,11 @@
 	}
 	if (j2k->state == J2K_STATE_NEOC) {
 		j2k_read_eoc(j2k);
+		/* Check one last time for errors during decoding before returning */
+		if (j2k->state & J2K_STATE_ERR) {
+			opj_image_destroy(image);
+			return NULL;
+		}
 	}
 
 	if (j2k->state != J2K_STATE_MT) {
diff -Naur openjpeg-1.5.1.old/libopenjpeg/jp2.c openjpeg-1.5.1/libopenjpeg/jp2.c
--- openjpeg-1.5.1.old/libopenjpeg/jp2.c	2012-09-13 09:58:39.000000000 +0200
+++ openjpeg-1.5.1/libopenjpeg/jp2.c	2014-10-14 09:38:25.794188900 +0200
@@ -806,6 +806,17 @@
 
 	jp2_write_ihdr(jp2, cio);
 
+	{
+		int curpos = cio_tell(cio);
+		cio_seek(cio, box.init_pos);
+		cio_skip(cio, box.length);
+		if ((cio_tell(cio) - box.init_pos) != box.length) {
+			opj_event_msg(jp2->cinfo, EVT_ERROR, "Box size exceeds size of codestream (expected: %d, real: %d)\n", box.length, (cio_tell(cio) - box.init_pos));
+			return OPJ_FALSE;
+		}
+		cio_seek(cio, curpos);
+	}
+
 	if (jp2->bpc == 255) {
 		jp2_write_bpcc(jp2, cio);
 	}
@@ -858,6 +869,13 @@
 	jp2->numcl = (box.length - 16) / 4;
 	jp2->cl = (unsigned int *) opj_malloc(jp2->numcl * sizeof(unsigned int));
 
+	if (cio_numbytesleft(cio) < ((int)jp2->numcl * 4)) {
+		opj_event_msg(cinfo, EVT_ERROR, "Not enough bytes in FTYP Box "
+				"(expected %d, but only %d left)\n",
+				((int)jp2->numcl * 4), cio_numbytesleft(cio));
+		return OPJ_FALSE;
+	}
+
 	for (i = 0; i < (int)jp2->numcl; i++) {
 		jp2->cl[i] = cio_read(cio, 4);	/* CLi */
 	}
diff -Naur openjpeg-1.5.1.old/libopenjpeg/t2.c openjpeg-1.5.1/libopenjpeg/t2.c
--- openjpeg-1.5.1.old/libopenjpeg/t2.c	2012-09-13 09:58:39.000000000 +0200
+++ openjpeg-1.5.1/libopenjpeg/t2.c	2014-10-14 09:38:25.798189200 +0200
@@ -340,6 +340,11 @@
 	int precno = pi->precno;	/* precinct value */
 	int layno  = pi->layno;		/* quality layer value */
 
+	if (!&(tile->comps[compno])) {
+		opj_event_msg(t2->cinfo, EVT_ERROR, "Trying to decode tile with no components!\n");
+		return -999;
+	}
+
 	opj_tcd_resolution_t* res = &tile->comps[compno].resolutions[resno];
 
 	unsigned char *hd = NULL;
diff -Naur openjpeg-1.5.1.old/libopenjpeg/tcd.c openjpeg-1.5.1/libopenjpeg/tcd.c
--- openjpeg-1.5.1.old/libopenjpeg/tcd.c	2012-09-13 09:58:39.000000000 +0200
+++ openjpeg-1.5.1/libopenjpeg/tcd.c	2014-10-14 09:38:25.801189300 +0200
@@ -667,8 +667,8 @@
 			y1 = j == 0 ? tilec->y1 : int_max(y1,	(unsigned int) tilec->y1);
 		}
 
-		w = int_ceildivpow2(x1 - x0, image->comps[i].factor);
-		h = int_ceildivpow2(y1 - y0, image->comps[i].factor);
+		w = int_ceildivpow2((long)(x1) - (long)(x0), image->comps[i].factor);
+		h = int_ceildivpow2((long)(y1) - (long)(y0), image->comps[i].factor);
 
 		image->comps[i].w = w;
 		image->comps[i].h = h;
@@ -1381,7 +1381,15 @@
 	if (l == -999) {
 		eof = 1;
 		opj_event_msg(tcd->cinfo, EVT_ERROR, "tcd_decode: incomplete bistream\n");
+		return OPJ_FALSE;
 	}
+
+	/* The code below assumes that numcomps > 0 */
+	if (tile->numcomps <= 0) {
+		opj_event_msg(tcd->cinfo, EVT_ERROR, "tcd_decode: tile has a zero or negative numcomps\n");
+		return OPJ_TRUE;
+	}
+
 	
 	/*------------------TIER1-----------------*/
 	
